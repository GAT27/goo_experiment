<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>stager_set</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///SCENE SETUP

data = 10;
backscene = 0;
donce = 2;
raw = 0;
output = 0;
dotal = 0;
combo = 0;
dombo = 0;
dharge = 0;
wall_l = instance_create(0,0,groundf);
wall_r = instance_create(0,0,groundf);
clock_s = 0;
surf0 = -1;
//g_ready = 0;
m_pause = 0;
m_debug = 0;

//Initialize 3D
d3d_start();
d3d_set_hidden(true);
//d3d_set_lighting(false);
d3d_set_culling(true);
//d3d_set_lighting(true);
d3d_light_define_direction(1, 0, -1, -1, c_white);
d3d_light_define_direction(2, 0, 1, -1, c_white);
d3d_light_enable(1, true);
d3d_light_enable(2, true);
//d3d_set_culling(true);
texture_set_interpolation(true);
//texture_set_interpolation(false);

//Camera controls
mouse_direction = 90;
zview = -10;
dist = 1000;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>g_ready</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>611</id>
        <kind>6</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>-1</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>clock_s</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>-1</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>room_speed</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ACTIVATION

if g_ready and !m_pause
{   if donce == 2//Initial selection
    {   //Characters
        data = data1;
        repeat 2 
        {   //Colors based on "http://colorizer.org/"
            switch data
            {   case 1:     data = power_one;
                            cH = 0; cS = 100; cV = 85;
                            break;
                case 2:     data = power_one;
                            cH = 240; cS = 100; cV = 80;
                            break;
                case 3:     data = power_one;
                            cH = 60; cS = 100; cV = 90;
                            break;
                case 4:     data = power_one;
                            cH = 130; cS = 100; cV = 45;
                            break;
                case 5:     data = power_one;
                            cH = 320; cS = 100; cV = 65;
                            break;
                case 6:     data = power_one;
                            cH = 170; cS = 100; cV = 90;
                            break;
                case 7:     data = power_one;
                            cH = 0; cS = 0; cV = 70;
                            break;
                /*default:    sprite_assign(block_tmp,block_blue);
                            player_one = instance_create(256,1008,power_one);
                            instance_create(196,224,power_one);
                            break;*/
            }
            if donce==2
            {   color_one = make_color_hsv(round(cH*255/360),
                                           round(cS*255/100),
                                           round(cV*255/100));
                player_one = instance_create(32*25,1023,data);
                data = data2;
                donce--;
            }
            else
            {   color_two = make_color_hsv(round(cH*255/360),
                                           round(cS*255/100),
                                           round(cV*255/100));
                player_two = instance_create(32*41,1023,data);
                
                player_one.skin = background_create_gradient(32,32,color_one,c_black,2);
                player_one.oppose = player_two;
                player_one.raw = 0;
                player_one.output = 0;
                player_one.dotal = 0;
                player_one.dombo = 0;
                player_two.skin = background_create_gradient(32,32,c_black,color_two,2);
                player_two.oppose = player_one;
                player_two.raw = 0;
                player_two.output = 0;
                player_two.dotal = 0;
                player_two.dombo = 0;
            }
        }
        
        //Stages
        switch data3&amp;127
        {   case 0:     //background_assign(back_tmp,back_yellow);
                        backscene = 0;
                        break;
            case 1:     //background_assign(back_tmp,back_green);
                        backscene = 1;
                        break;
        }
        
        //Timer
        data3 = data3&gt;&gt;7;
        clock_s = (data3&amp;15) * 300;
        data = 10;
        alarm[1] = 1 * room_speed;
        g_ready--;
        donce--;
    }
    
    else if donce//Move again after pause or lag
    {   instance_activate_object(player_one);
        instance_activate_object(player_one.hrbx);
        with player_one if ds_list_size(abox)
        for (var i=ds_list_size(abox)-1;i&gt;=0;i--)
        {   var cbox = abox[|i];
            instance_activate_object(cbox[0]);
        }
        instance_activate_object(player_two);
        instance_activate_object(player_two.hrbx);
        with player_two if ds_list_size(abox)
        for (i=ds_list_size(abox)-1;i&gt;=0;i--)
        {   cbox = abox[|i];
            instance_activate_object(cbox[0]);
        }
        donce--;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///STAGER

//Check for end
if ((puppeteer.playb and (data&amp;1 or (data&gt;&gt;10)&amp;1))//At playback
or (m_pause and ((data&gt;&gt;7)&amp;1 or (data&gt;&gt;17)&amp;1))//At pausing
or (clock_s&lt;0))//At timer or defeat
and g_ready
{   file_text_close(puppeteer.file);
    d3d_set_lighting(false);
    d3d_end();
    ds_list_destroy(player_one.abox);
    ds_list_destroy(player_two.abox);
    scr_delete_animation(player_one.anim);
    scr_delete_animation(player_two.anim);
    background_delete(player_one.skin);
    background_delete(player_two.skin);
    surface_free(surf0);
    surface_free(surf1);
    surface_free(surf2);
    surface_free(surf3);
    if puppeteer.online
    {   network_destroy(puppeteer.peer);
        buffer_delete(puppeteer.buffer_pak);
        ds_queue_destroy(puppeteer.data_t);
    }
    room_goto(stage_room);
}

//Game is in motion
if g_ready and !m_pause
{   player_one.data = (data&gt;&gt;1)&amp;511;
    player_two.data = (data&gt;&gt;11)&amp;511;
}

//Manual pausing
if g_ready
{   if data&amp;1 or (data&gt;&gt;10)&amp;1
    {   if !m_pause
        {   m_pause--;
            if m_pause == -6
                m_pause = 1;
        }
        else if m_pause &gt; 1
            m_pause = -6;
    }
    else
    {   if m_pause &lt; -6
            m_pause = 0;
        else if m_pause != 0
            m_pause++;
    }
}

//Prepare to pause game
if !(g_ready and !m_pause) and !alarm[1]
{   alarm[0] += 1;
    if !donce
    {   surf0 = surface_create(display_get_gui_width(),display_get_gui_height());
        surface_copy(surf0,0,0,application_surface);
        with player_one
        {   if ds_list_size(abox)
            for (var i=ds_list_size(abox)-1;i&gt;=0;i--)
            {   var cbox = abox[|i];
                instance_deactivate_object(cbox[0]);
            }
            instance_deactivate_object(hrbx);
            instance_deactivate_object(self);
        }
        with player_two
        {   if ds_list_size(abox)
            for (i=ds_list_size(abox)-1;i&gt;=0;i--)
            {   cbox = abox[|i];
                instance_deactivate_object(cbox[0]);
            }
            instance_deactivate_object(hrbx);
            instance_deactivate_object(self);
        }
        donce++;
    }
}

//Attack trading check
if !combo and (player_one.combo==1) and (player_two.combo==1)
    var trade = -1;
else
    var trade = (player_one.combo and player_two.combo);

//Combo and damage calculation
repeat 1 + abs(trade)
{   if (player_one.combo&gt;combo) or (player_two.combo&gt;combo)//Attacker combo setup
    {   if player_one.combo == 1
        {   P = player_one;
            O = player_two;
            tot = 0;
            hstun = 0;
            dotal = 0;
            for (var i=64;i&lt;=184;i+=8)
                tot += P.action[i,4];
            decay = ds_queue_create();
        }
        else if player_two.combo == 1
        {   P = player_two;
            O = player_one;
            tot = 0;
            hstun = 0;
            dotal = 0;
            for (var i=64;i&lt;=184;i+=8)
                tot += P.action[i,4];
            decay = ds_queue_create();
        }
        
        //Get baseline calculations
        var st4 = O.htate - (O.htate%8);
        var fresh = tot / (tot + P.action[st4,4] - 1);
        raw = P.damage[O.htate,0] * fresh;
        brek = P.blocks[O.htate,0] * raw;
        
        //Modify with charge once in combo if strong
        if (O.htate&amp;8) and (O.htate&lt;192)
        {   raw *= 1 + P.charge/(P.stock*20);
            brek *= 1 + P.charge/(P.stock*20);
            if !dharge
                dharge = -(P.charge+1);
        }
        
        //Modify deficiency if sbecial, then calculate shield loss plus gauge
        if O.htate &gt;= 192
            O.sty *= 0.9;
        output = ceil(brek * (1-O.defense_pri/50) * O.sty);
        P.gauge += output * (60 + P.stamina_sec*8) / 100;
        
        //If shield breaks, then attack goes through, become zero deficiency
        O.shield -= output;
        if O.shield &lt;= 0
        {   O.shield = 0;
            O.state = O.brek;
            O.sty = 0;
            O.hlag = -1;
        }
        
        //Attack goes through, zero deficiency
        if !O.sty
        {   if !(O.htate%8)//Count new attacks
            {   if O.htate &lt; 192//Add to decay if not sbecial
                    ds_queue_enqueue(decay,st4);
                if dharge &lt; 0//First strong, lock charge
                    dharge *= -1;
                else if dharge//Additional strongs, zero charge and return to pre-raw
                {   P.charge = -1;
                    raw = P.damage[O.htate,0] * fresh;
                }
            }
            hstun++;//Calculate hitstun to opponent, gets smaller in combo
            O.buffer_mtr -= P.damage[O.htate,1]
                          - ((hstun - (hstun%2))
                          * (100 - ((10-O.speed_sec)*6)) / 200);
        }
        else//Calculate blockstun to opponent
            O.buffer_mtr -= P.blocks[O.htate,1]
                          * (100 - (O.defense_sec*6)) / 100;
        
        //Calculate damage loss plus gauge, then update meters
        output = ceil(raw * (1-O.defense_pri/50) * (1-O.sty));
        P.gauge += output * (60 + P.stamina_sec*8) / 100;
        dotal += output;
        O.life -= output;
        O.will -= output;
        P.will += output;
        
        //Combo update based if grabbed
        if (O.htate&gt;=224 and O.htate&lt;240) and !(O.htate&amp;7)
            P.combo--;
        else
            combo++;
        dombo = combo;
    }
    ////
    if combo//During attackers combo
    {   //Charge locking
        if P.charge == -1
            dharge = 1;
        else if dharge
            P.charge = dharge - 1;
        
        //Display meters
        P.raw = raw;
        P.output = output;
        P.dotal = dotal;
        P.dombo = dombo * (O.sty&lt;=0);
        
        //Opponent escapes, dropping or interrupt, or blocks at start
        if (O.buffer_mtr&gt;59) or abs(trade) or (O.sty&gt;0)
        {   while !ds_queue_empty(decay)//Decay after combo end
            {   tot = ds_queue_dequeue(decay);
                P.action[tot,4] += 10 - P.power_pri;
            }
            ds_queue_destroy(decay);
            
            //End combo setup
            hstun = 0;
            P.combo = 0;
            combo = 0;
            trade -= power(-2,!trade);
            if dharge
            {   P.charge = 0;
                dharge = 0;
            }
        }
    }
}

//Player distance room
var center_sp = (player_one.x + player_two.x) / 2;
wall_l.x = center_sp - 17*32;
wall_r.x = center_sp + 16*32;
with wall_l
if distance_to_object(stager.player_one)
&lt; distance_to_object(stager.player_two)
    y = stager.player_one.y - 64;
else
    y = stager.player_two.y - 64;
with wall_r
if distance_to_object(stager.player_one)
&lt; distance_to_object(stager.player_two)
    y = stager.player_one.y - 64;
else
    y = stager.player_two.y - 64;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///HUD

d3d_set_lighting(false);
d3d_set_culling(false);

//Main surface capture
var hud_w = display_get_gui_width();
var hud_h = display_get_gui_height();
var hud_s = min(hud_w,hud_h) * 0.8;
if surface_get_width(application_surface) != hud_w
or surface_get_height(application_surface) != hud_h
{   surface_resize(application_surface,hud_w,hud_h);
    if !g_ready or m_pause
    {   if surface_exists(surf0)
            surface_resize(surf0,hud_w,hud_h);
        else
        {   surf0 = surface_create(hud_w,hud_h);
            surface_set_target(surf0);
            draw_clear_alpha(0,1);
            draw_text_color(hud_w/2,hud_h/2,
                            "why would you resize?",
                            c_red,c_blue,c_yellow,c_green,1);
            surface_reset_target();
        }
    }
}
draw_set_font(HUD_test);

//Calc and setup for frozen or realtime display
if !g_ready or m_pause
{   if surface_exists(surf0)
        draw_surface(surf0,0,0);
}
else if surface_exists(surf0)
{   draw_surface(surf0,0,0);
    surface_free(surf0);
}
////
if !player_one.goo
    var rot_b1 = 90;
else
    var rot_b1 = 90 * (540-260-40*player_one.goo) / 540;
var ellx_b1 = hud_s * (1-dsin(rot_b1)) / 2;
var elly_b1 = hud_s * (1-dcos(rot_b1)) / 2;
var rot_g1 = 90 * (540-player_one.gauge) / 540;
var ellx_g1 = hud_s * (1-dsin(rot_g1)) / 2;
var elly_g1 = hud_s * (1-dcos(rot_g1)) / 2;
var rot_c1 = 90 * (540-300-40*player_one.goo) / 540;
var ellx_c1 = hud_s * (1-dsin(rot_c1)) / 2;
var elly_c1 = hud_s * (1-dcos(rot_c1)) / 2;
////
if !player_two.goo
    var rot_b2 = -90;
else
    var rot_b2 = 90 * (260+40*player_two.goo-540) / 540;
var ellx_b2 = hud_s * (1-dsin(rot_b2)) / 2;
var elly_b2 = hud_s * (1-dcos(rot_b2)) / 2;
var rot_g2 = 90 * (player_two.gauge-540) / 540;
var ellx_g2 = hud_s * (1-dsin(rot_g2)) / 2;
var elly_g2 = hud_s * (1-dcos(rot_g2)) / 2;
var rot_c2 = 90 * (300+40*player_two.goo-540) / 540;
var ellx_c2 = hud_s * (1-dsin(rot_c2)) / 2;
var elly_c2 = hud_s * (1-dcos(rot_c2)) / 2;
////
var rot_r = -40;
var scl_r = 0.25;
//var ellx_r = hud_s * (1-dsin(rot_r) + dsin(rot_r)*(1-scl_r)) / 2;
var ellx_r = hud_s * (1-dsin(rot_r)*scl_r) / 2;
var elly_r = hud_s * (1-dcos(rot_r)*scl_r) / 2;
if !player_one.stock
    var rot_h1 = -180;
else
    var rot_h1 = 180 * ((player_one.charge/20/player_one.stock) - 1);
var ellx_h1 = hud_s * (1-dsin(rot_h1)) / 2;
var elly_h1 = hud_s * (1-dcos(rot_h1)) / 2;
if !player_two.stock
    var rot_h2 = -180;
else
    var rot_h2 = 180 * ((player_two.charge/20/player_two.stock) - 1);
var ellx_h2 = hud_s * (1-dsin(rot_h2)) / 2;
var elly_h2 = hud_s * (1-dcos(rot_h2)) / 2;
////
var rot_w = 90 * (1 - (player_one.will/2000));
var ellx_w = hud_s * (1-dsin(rot_w)) / 2;
var elly_w = hud_s * (1-dcos(rot_w)) / 2;
var rot_s1 = 90 * (1 - (player_one.shield/2000));
var ellx_s1 = hud_s * (1-dsin(rot_s1)) / 2;
var elly_s1 = hud_s * (1-dcos(rot_s1)) / 2;
var rot_s2 = 90 * ((player_two.shield/2000) - 1);
var ellx_s2 = hud_s * (1-dsin(rot_s2)) / 2;
var elly_s2 = hud_s * (1-dcos(rot_s2)) / 2;
////
var plah = 0.9;
var plav = 0.1;
draw_set_circle_precision(48);
surf1 = surface_create(hud_s,hud_s);
surf2 = surface_create(hud_s,hud_s);
surf3 = surface_create(hud_s,hud_s);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);

//Player 1 goo
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  merge_color(c_lime,0,(player_one.goo-1)/10),
                  merge_color(c_lime,0,(player_one.goo-1)/10),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_b1,elly_b1,-1,1,rot_b1,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  merge_color(c_lime,0,player_one.goo/10),
                  merge_color(c_lime,0,player_one.goo/10),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_g1,elly_g1,-1,1,rot_g1,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  make_color_hsv(16+32*player_one.goo,192,96),
                  make_color_hsv(64+32*player_one.goo,192,96),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_c1,elly_c1,1,1,rot_c1,-1,-1,-1,-1,1);
////
draw_set_blend_mode(bm_subtract);
//draw_ellipse(0,hud_s*0.35,hud_s,hud_s*0.75,false);
draw_circle(hud_s/2,hud_s*0.75,hud_s/2,false);
draw_set_blend_mode(bm_normal);
surface_reset_target();
draw_surface_part_ext(surf1,0,0,hud_s/2,hud_s/2,
                      (1-plah)*hud_w/2,
                      (plav-0.01)*hud_h,
                      (plah+0.1)*0.35*2*hud_w/hud_s,
                      0.14*2*hud_h/hud_s,
                      -1,1);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);

//Player 2 goo
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  merge_color(c_lime,0,(player_two.goo-1)/10),
                  merge_color(c_lime,0,(player_two.goo-1)/10),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_b2,elly_b2,1,1,rot_b2,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  merge_color(c_lime,0,player_two.goo/10),
                  merge_color(c_lime,0,player_two.goo/10),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_g2,elly_g2,1,1,rot_g2,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  make_color_hsv(16+32*player_two.goo,192,96),
                  make_color_hsv(64+32*player_two.goo,192,96),false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                     ellx_c2,elly_c2,-1,1,rot_c2,-1,-1,-1,-1,1);
////
draw_set_blend_mode(bm_subtract);
//draw_ellipse_color(0,hud_s*0.35,hud_s,hud_s*0.75,-1,-1,false);
draw_circle(hud_s/2,hud_s*0.75,hud_s/2,false);
draw_set_blend_mode(bm_normal);
surface_reset_target();
draw_surface_part_ext(surf1,hud_s/2,0,hud_s/2,hud_s/2,
                      (plah-1)*hud_w/2 - (plah+0.1)*0.35*hud_w + hud_w,
                      (plav-0.01)*hud_h,
                      (plah+0.1)*0.35*2*hud_w/hud_s,
                      0.14*2*hud_h/hud_s,
                      -1,1);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);

//Players boost
if player_one.boost == 100
    draw_circle_color(hud_s/2,hud_s/2,hud_s/10,
                      c_yellow,c_yellow,false);
else
    draw_circle_color(hud_s/2,hud_s/2,hud_s*player_one.boost/1000,
                      c_olive,c_olive,false);
surface_reset_target();
draw_surface_part_ext(surf2,hud_s/2,0,hud_s/2,hud_s,
                      hud_s/2,0,-1,1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
if player_two.boost == 100
    draw_circle_color(hud_s/2,hud_s/2,hud_s/10,
                      c_yellow,c_yellow,false);
else
    draw_circle_color(hud_s/2,hud_s/2,hud_s*player_two.boost/1000,
                      c_olive,c_olive,false);
surface_reset_target();
draw_surface_part_ext(surf2,hud_s/2,0,hud_s/2,hud_s,
                      hud_s/2,0,1,1,-1,1);
////
surface_reset_target();
draw_surface_ext(surf1,
                 (hud_w-hud_s)/2,
                 (-0.32+plav)*hud_h,
                 1,1,0,-1,1);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);
surface_set_target(surf3);
draw_clear_alpha(0,0);

//Player 1 stock and charge
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  c_red,c_red,false);
surface_reset_target();
draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                     ellx_h1,elly_h1,1,1,rot_h1,-1,-1,-1,-1,1);
surface_set_target(surf3);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  color_one,color_one,false);
surface_reset_target();
draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                     hud_s/2,0,1,1,0,-1,-1,-1,-1,0.45);
for (var i=0;i&lt;player_one.stock;i++)
    draw_circle_color(//hud_s/2 + hud_s*(0.5+0.4)/2*dsin((10+20*i) * 180/20/player_one.stock),
                      hud_s * (1+0.9*dsin((90+180*i)/player_one.stock)) / 2,
                      hud_s * (1+0.9*dcos((90+180*i)/player_one.stock)) / 2,
                      hud_s*(0.5-0.4)/2,
                      color_one,color_one,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_r,elly_r,scl_r,scl_r,rot_r,-1,-1,-1,-1,1);
////
draw_set_blend_mode(bm_subtract);
draw_circle(hud_s/2,hud_s/2,hud_s*scl_r*0.4,false);
draw_set_blend_mode(bm_normal);
surface_reset_target();
draw_set_halign(fa_right);
line = "    " + string(floor(player_one.life));
for (i=5;i&gt;0;i--)
{   var rot_l = rot_r + (5.5-i)*180/5;
    //var ellx_l = hud_s*(1-dsin(rot_l) + dsin(rot_l)*(1-1*scl_r*1.3))/2 + ((1-plah*0.9)*hud_w-hud_s)/2;
    var ellx_l = (hud_s*(1-dsin(rot_l)*scl_r*1.3) + (1-plah*0.9)*hud_w-hud_s) / 2;
    var elly_l = hud_s*(1-dcos(rot_l)*scl_r*1.3)/2 + (-0.15+plav)*hud_h;
    draw_text_transformed_color(ellx_l,elly_l,
                                string_char_at(line,string_length(string(floor(player_one.life)))+i-1),
                                hud_w/view_wview[0],
                                hud_h/view_hview[0],
                                rot_l,0,0,0,0,1);
}
draw_set_halign(fa_left);
draw_surface_ext(surf1,
                 ((1-plah*0.9)*hud_w-hud_s)/2,
                 (-0.15+plav)*hud_h,
                 1,1,0,-1,1);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);
surface_set_target(surf3);
draw_clear_alpha(0,0);

//Player 2 stock and charge
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  c_red,c_red,false);
surface_reset_target();
draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                     ellx_h2,elly_h2,1,1,rot_h2,-1,-1,-1,-1,1);
surface_set_target(surf3);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  color_two,color_two,false);
surface_reset_target();
draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                     hud_s/2,0,1,1,0,-1,-1,-1,-1,0.45);
for (i=0;i&lt;player_two.stock;i++)
    draw_circle_color(hud_s * (1+0.9*dsin((90+180*i)/player_two.stock)) / 2,
                      hud_s * (1+0.9*dcos((90+180*i)/player_two.stock)) / 2,
                      hud_s*(0.5-0.4)/2,
                      color_two,color_two,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_r,elly_r,scl_r,scl_r,rot_r,-1,-1,-1,-1,1);
////
draw_set_blend_mode(bm_subtract);
draw_circle(hud_s/2,hud_s/2,hud_s*scl_r*0.4,false);
draw_set_blend_mode(bm_normal);
surface_reset_target();
draw_set_halign(fa_right);
line = string(floor(player_two.life)) + "    ";
for (i=1;i&lt;=5;i++)
{   rot_l = -(rot_r + (i-0.5)*180/5);
    ellx_l = (hud_s*(1-dsin(rot_l)*scl_r*1.3) + (1+plah*0.9)*hud_w-hud_s) / 2;
    elly_l = hud_s*(1-dcos(rot_l)*scl_r*1.3)/2 + (-0.15+plav)*hud_h;
    draw_text_transformed_color(ellx_l,elly_l,
                                string_char_at(line,i),
                                hud_w/view_wview[0],
                                hud_h/view_hview[0],
                                rot_l,0,0,0,0,1);
}
draw_set_halign(fa_left);
draw_surface_ext(surf1,
                 ((1+plah*0.9)*hud_w+hud_s)/2,
                 (-0.15+plav)*hud_h,
                 -1,1,0,-1,1);
surface_set_target(surf1);
draw_clear_alpha(0,0);
surface_set_target(surf2);
draw_clear_alpha(0,0);

//Player 1 will and shield
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  color_one,color_one,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_w,elly_w,-1,1,rot_w,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s*0.41,
                  c_maroon,c_maroon,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_w,elly_w,-1,1,rot_w,-1,-1,-1,-1,0.98);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  c_maroon,c_maroon,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_s1,elly_s1,-1,1,rot_s1,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);

//Player 2 will and shield
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  color_two,color_two,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_w,elly_w,1,1,rot_w,-1,-1,-1,-1,1);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s*0.41,
                  c_navy,c_navy,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_w,elly_w,1,1,rot_w,-1,-1,-1,-1,0.98);
surface_set_target(surf2);
draw_clear_alpha(0,0);
////
draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                  c_navy,c_navy,false);
surface_reset_target();
draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                     ellx_s2,elly_s2,1,1,rot_s2,-1,-1,-1,-1,1);

//End and clean top display
draw_set_blend_mode(bm_subtract);
draw_rectangle(-hud_s*0.1,hud_s*0.5,hud_s*1.1,hud_s,false);
draw_ellipse(-hud_s*0.1,hud_s*0.17,hud_s*1.1,hud_s*1.67,false);
draw_set_blend_mode(bm_normal);
surface_reset_target();
draw_surface_stretched(surf1,
                       (1-plah)*hud_w/2,
                       (plav-0.05)*hud_h,
                       plah*hud_w,
                       hud_h*0.3);
surface_free(surf3);
surface_free(surf2);
surface_free(surf1);

//Show debug
if m_debug
{   for (i=0;i&lt;16;i++)//Player 1 decay stats
    {   switch i%8
        {   case 0: line = "still: "; break;
            case 1: line = "tilt:  "; break;
            case 2: line = "rush:  "; break;
            case 3: line = "down:  "; break;
            case 4: line = "up:    "; break;
            case 5: line = "nair:  "; break;
            case 6: line = "fair:  "; break;
            case 7: line = "dair:  "; break;
        }
        if i&lt;8
            line += string(player_one.action[64+i*16,4]);
        else
            line += string(player_one.action[72+(i-8)*16,4]);
        draw_text_transformed_color(0,hud_h*(0.42+0.02*i),
                                    line,
                                    0.3*hud_w/view_wview[0],
                                    0.3*hud_h/view_hview[0],
                                    0,lerp(c_navy,c_maroon,(i-i%8)/8),lerp(c_navy,c_maroon,(i-i%8)/8),
                                    lerp(c_navy,c_maroon,(i-i%8)/8),lerp(c_navy,c_maroon,(i-i%8)/8),1);
    }
    
    for (i=0;i&lt;10;i++)//Player 1 debug
    {   switch i
        {   case 0: line = "Raw: " + string(player_one.raw); break;
            case 1: line = "Output: " + string(player_one.output); break;
            case 2: line = "Total: " + string(player_one.dotal); break;
            case 3: line = "Ground: " + string(player_one.grounded); break;
            case 4: line = "Ping: " + string(puppeteer.ping_avr); break;
            
            case 5: line = "State: " + string(player_one.state); break;
            case 6: line = "Buffer: " + string(player_one.buffer_mtr); break;
            case 7: line = "Combo: " + string(player_one.dombo); break;
            case 8: if ds_list_size(player_one.abox)
                    {   var cbox = player_one.abox[|ds_list_size(player_one.abox)-1]
                        line = "Attack: " + string(cbox[1]);
                    }
                    else
                        line = "Attack: " + string(0);
                    break;
            case 9: line = "1000ms: " + string(puppeteer.ping_m); break;
        }
        draw_text_transformed_color(hud_w*(0.16+0.12*(i-i%5)/5),
                                    hud_h*(0.30+0.03*(i%5)),
                                    line,
                                    0.4*hud_w/view_wview[0],
                                    0.4*hud_h/view_hview[0],
                                    0,c_fuchsia,c_black,c_black,c_black,1);
    }
    
    for (i=0;i&lt;10;i++)//Player 2 debug
    {   switch i
        {   case 0: line = "Raw: " + string(player_two.raw); break;
            case 1: line = "Output: " + string(player_two.output); break;
            case 2: line = "Total: " + string(player_two.dotal); break;
            case 3: line = "Ground: " + string(player_two.grounded); break;
            case 4: line = "Ping: " + string(puppeteer.ping_avr); break;
            
            case 5: line = "State: " + string(player_two.state); break;
            case 6: line = "Buffer: " + string(player_two.buffer_mtr); break;
            case 7: line = "Combo: " + string(player_two.dombo); break;
            case 8: line = "Gravity: " + string(player_two.gvy); break;
            case 9: line = "1000ms: " + string(puppeteer.ping_m); break;
        }
        draw_text_transformed_color(hud_w*(0.64+0.12*(i-i%5)/5),
                                    hud_h*(0.30+0.03*(i%5)),
                                    line,
                                    0.4*hud_w/view_wview[0],
                                    0.4*hud_h/view_hview[0],
                                    0,c_fuchsia,c_black,c_black,c_black,1);
    }
}

//Timer
draw_set_halign(fa_right);
draw_set_valign(fa_bottom);
draw_text_transformed_color(hud_w*0.5,hud_h,
                            string(clock_s)+".",
                            hud_w/view_wview[0],
                            hud_h/view_hview[0],
                            0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
draw_set_halign(fa_left);
draw_text_transformed_color(hud_w*0.5,hud_h*0.99,
                            string(alarm[0]),
                            0.5*hud_w/view_wview[0],
                            0.5*hud_h/view_hview[0],
                            0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
draw_set_valign(fa_top);

d3d_set_culling(true);
//d3d_set_lighting(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CAMERA

draw_set_color(c_green);
//draw_set_alpha(1);
//draw_set_color(c_white);

//PS3 camera controls
if (g_ready and !m_pause) or alarm[1]
{   if gamepad_is_connected(0)
    {   if (abs(point_distance(0,0,gamepad_axis_value(0,gp_axisrh),
                gamepad_axis_value(0,gp_axisrv))) &gt; 0.2)
        {   mouse_direction += gamepad_axis_value(0,gp_axisrh) * 3;
            zview += gamepad_axis_value(0,gp_axisrv) * 3;
        }
        dist += gamepad_button_value(0,gp_shoulderlb) * 12.5;
        dist += -gamepad_button_value(0,gp_shoulderrb) * 12.5;
    }
    
    var cc = cos(zview*pi/180);
    var cx = cos(mouse_direction*pi/180)*cc;
    var cy = sin(zview*pi/180);
    var cz = sin(mouse_direction*pi/180)*cc;
    var target_x = (player_one.x + player_two.x) / 2;
    var target_y = (player_one.y + player_two.y) / 2;
    var target_z = (player_one.z + player_two.z) / 2;
    var hc = 050;
    var ht = 150;
    var xup = 0;
    var yup = -1;
    var zup = 0;
    
    d3d_set_projection(target_x+(cx*dist),target_y+(cy*dist)-hc,target_z+(cz*dist),
                       target_x,target_y-ht,target_z,xup,yup,zup);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
