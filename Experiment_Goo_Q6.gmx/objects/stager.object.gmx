<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>stager_set</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///SCENE SETUP

//Parameters
data = 10;
backscene = 0;
donce = 2;
g_ready = 0;
combo = 0;
dombo = 0;
raw = 0;
output = 0;
dotal = 0;
hstun = 0;
wall_l = instance_create(0,0,groundf);
wall_r = instance_create(0,0,groundf);
clock_s = 0;
surf0 = -1;
debugg = 0;

//Initialize 3D
d3d_start();
d3d_set_hidden(true);
//d3d_set_lighting(false);
d3d_set_culling(true);
//d3d_set_lighting(true);
d3d_light_define_direction(1, 0, -1, -1, c_white);
d3d_light_define_direction(2, 0, 1, -1, c_white);
d3d_light_enable(1, true);
d3d_light_enable(2, true);
//d3d_set_culling(true);
texture_set_interpolation(true);
//texture_set_interpolation(false);

//Camera controls
mouse_direction = 90;
zview = -10;
dist = 1000;
xup = 0;
yup = -1;
zup = 0;
target_x = 0;
target_y = 0;
target_z = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///S TICK

clock_s--;
player_one.tick = 1;
player_two.tick = 1;
alarm[0] = room_speed;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>g_ready</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>1</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ACTIVATION

if donce == 2//Initial selection
{   //Characters
    data = data1;
    repeat 2 
    {   //Colors based on "http://colorizer.org/"
        switch data
        {   case 1:     data = power_one;
                        cH = 0; cS = 100; cV = 85;
                        break;
            case 2:     data = power_one;
                        cH = 240; cS = 100; cV = 80;
                        break;
            case 3:     data = power_one;
                        cH = 60; cS = 100; cV = 90;
                        break;
            case 4:     data = power_one;
                        cH = 130; cS = 100; cV = 45;
                        break;
            case 5:     data = power_one;
                        cH = 320; cS = 100; cV = 65;
                        break;
            case 6:     data = power_one;
                        cH = 170; cS = 100; cV = 90;
                        break;
            case 7:     data = power_one;
                        cH = 0; cS = 0; cV = 70;
                        break;
            /*
            default:    sprite_assign(block_tmp,block_blue);
                        player_one = instance_create(256,1008,power_one);
                        instance_create(196,224,power_one);
                        break;*/
        }
        if donce==2
        {   color_one = make_color_hsv(round(cH*255/360),
                                       round(cS*255/100),
                                       round(cV*255/100));
            player_one = instance_create(32*25,1023,data);
            data = data2;
            donce--;
        }
        else
        {   color_two = make_color_hsv(round(cH*255/360),
                                       round(cS*255/100),
                                       round(cV*255/100));
            player_two = instance_create(32*41,1023,data);
            
            player_one.skin = background_create_gradient(32,32,color_one,c_black,2);
            player_one.oppose = player_two;
            player_one.tick = 0;
            player_one.raw = 0;
            player_one.output = 0;
            player_one.dotal = 0;
            player_one.dombo = 0;
            player_two.skin = background_create_gradient(32,32,c_black,color_two,2);
            player_two.oppose = player_one;
            player_two.tick = 0;
            player_two.raw = 0;
            player_two.output = 0;
            player_two.dotal = 0;
            player_two.dombo = 0;
        }
    }
    
    //Stages
    switch data3&amp;127
    {   case 0:     //background_assign(back_tmp,back_yellow);
                    backscene = 0;
                    break;
        case 1:     //background_assign(back_tmp,back_green);
                    backscene = 1;
                    break;
    }
    
    //Timer
    data3 = data3&gt;&gt;7;
    clock_s = (data3&amp;15) * 300;
    data = 10;
    alarm[0] = 1;
    donce--;
}

else if donce//Move again after pause or lag
{   instance_activate_object(player_one);
    instance_activate_object(player_two);
    donce--;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///STAGER

//Game is in motion
if g_ready
{   //Check for end, otherwise, send player data
    if data&amp;1 or (data&gt;&gt;10)&amp;1 or (clock_s&lt;0)
    {   file_text_close(puppeteer.file);
        d3d_set_lighting(false);
        d3d_end();
        ds_list_destroy(player_one.abox);
        ds_list_destroy(player_two.abox);
        scr_delete_animation(player_one.anim);
        scr_delete_animation(player_two.anim);
        background_delete(player_one.skin);
        background_delete(player_two.skin);
        if puppeteer.online
        {   network_destroy(puppeteer.peer);
            buffer_delete(puppeteer.buffer_pak);
            ds_queue_destroy(puppeteer.data_t);
        }
        room_goto(stage_room);
    }
    player_one.data = (data&gt;&gt;1)&amp;511;
    player_two.data = (data&gt;&gt;11)&amp;511;
    
    //Combo and damage calculation
    if (player_one.combo&gt;combo) or (player_two.combo&gt;combo)
    {   if player_one.combo==1
        {   P = player_one;
            O = player_two;
            tot = 0;
            hstun = 0;
            dotal = 0;
            for (var i=64;i&lt;=184;i+=8)
                tot += P.action[i,4];
            decay = ds_queue_create();
        }
        else if player_two.combo==1
        {   P = player_two;
            O = player_one;
            tot = 0;
            hstun = 0;
            dotal = 0;
            for (var i=64;i&lt;=184;i+=8)
                tot += P.action[i,4];
            decay = ds_queue_create();
        }
        
        st4 = O.htate - (O.htate % 8);
        fresh = tot / (tot + P.action[st4,4] - 1);
        raw = P.damage[O.htate,0] * fresh;
        brek = P.blocks[O.htate,0] * raw;
        if !((O.htate+8)%16)
        {   raw *= 1 + P.charge/(P.stock*20);
            brek *= 1 + P.charge/(P.stock*20);
            P.charge = 0;
        }
        if O.htate&gt;=192
            O.sty *= 0.9;
        
        output = ceil(brek * (1-O.defense_pri/50) * O.sty);
        P.bar += output * (60 + P.stamina_sec*8) / 100;
        O.shield -= output;
        if O.shield&lt;=0
        {   O.shield = 0;
            O.state = O.brek;
            O.sty = 0;
            O.hlag = -1;
        }
        output = ceil(raw * (1-O.defense_pri/50) * (1-O.sty));
        P.bar += output * (60 + P.stamina_sec*8) / 100;
        
        if !O.sty
        {   if !(O.htate%8) and !(O.htate&gt;=192)
                ds_queue_enqueue(decay,st4);
            hstun++;
            O.buffer_mtr -= P.damage[O.htate,1]
                          - ((hstun - (hstun%2))
                          * (100 - ((10-O.speed_sec)*6)) / 200);
        }
        else
            O.buffer_mtr -= P.blocks[O.htate,1]
                          * (100 - (O.defense_sec*6)) / 100;
        
        dotal += output;
        O.life -= output;
        O.will -= output;
        P.will += output;
        combo++;
        dombo = combo;
    }
    if combo and (O.buffer_mtr&gt;59 or O.sty&gt;0)
    {   while !ds_queue_empty(decay)
        {   tot = ds_queue_dequeue(decay);
            P.action[tot,4] += 10 - P.power_pri;
        }
        ds_queue_destroy(decay);
        //P.combo = 0;
        combo = 0;
        //dotal = 0;
        hstun = 0;
    }
    
    //Player distance room
    center_sp = (player_one.x + player_two.x) / 2;
    wall_l.x = center_sp - 17*32;
    wall_r.x = center_sp + 16*32;
    with wall_l
    if distance_to_object(stager.player_one)
    &lt; distance_to_object(stager.player_two)
        y = stager.player_one.y - 64;
    else
        y = stager.player_two.y - 64;
    with wall_r
    if distance_to_object(stager.player_one)
    &lt; distance_to_object(stager.player_two)
        y = stager.player_one.y - 64;
    else
        y = stager.player_two.y - 64;
}

//Prepare to pause game
else if !donce
    donce++;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///HUD

d3d_set_lighting(false);
d3d_set_culling(false);

var hud_w = display_get_gui_width();
var hud_h = display_get_gui_height();
var hud_s = min(hud_w,hud_h) * 0.8;
if surface_get_width(application_surface) != hud_w
or surface_get_height(application_surface) != hud_h
{   surface_resize(application_surface,hud_w,hud_h);
    if surface_exists(surf0)
    {   surface_resize(surf0,hud_w,hud_h);
        surface_copy(surf0,0,0,application_surface);
    }
}
draw_set_font(HUD_test);

//Realtime display
if g_ready
{   //Calc and setup for display
    if surface_exists(surf0)
    {   surface_free(surf0);
        surf0 = -1;
    }
    ////
    if !player_one.goo
        var rot_b1 = 90;
    else
        var rot_b1 = 90 * (540-260-40*player_one.goo) / 540;
    var ellx_b1 = hud_s * (1-dsin(rot_b1)) / 2;
    var elly_b1 = hud_s * (1-dcos(rot_b1)) / 2;
    var rot_g1 = 90 * (540-player_one.bar) / 540;
    var ellx_g1 = hud_s * (1-dsin(rot_g1)) / 2;
    var elly_g1 = hud_s * (1-dcos(rot_g1)) / 2;
    var rot_c1 = 90 * (540-300-40*player_one.goo) / 540;
    var ellx_c1 = hud_s * (1-dsin(rot_c1)) / 2;
    var elly_c1 = hud_s * (1-dcos(rot_c1)) / 2;
    ////
    if !player_two.goo
        var rot_b2 = -90;
    else
        var rot_b2 = 90 * (260+40*player_two.goo-540) / 540;
    var ellx_b2 = hud_s * (1-dsin(rot_b2)) / 2;
    var elly_b2 = hud_s * (1-dcos(rot_b2)) / 2;
    var rot_g2 = 90 * (player_two.bar-540) / 540;
    var ellx_g2 = hud_s * (1-dsin(rot_g2)) / 2;
    var elly_g2 = hud_s * (1-dcos(rot_g2)) / 2;
    var rot_c2 = 90 * (300+40*player_two.goo-540) / 540;
    var ellx_c2 = hud_s * (1-dsin(rot_c2)) / 2;
    var elly_c2 = hud_s * (1-dcos(rot_c2)) / 2;
    ////
    var rot_r = -40;
    //xxb++;
    var scl_r = 0.25;
    //var ellx_r = hud_s * (1-dsin(rot_r) + dsin(rot_r)*(1-scl_r)) / 2;
    var ellx_r = hud_s * (1-dsin(rot_r)*scl_r) / 2;
    var elly_r = hud_s * (1-dcos(rot_r)*scl_r) / 2;
    var rot_h1 = 180 * ((player_one.charge/20/player_one.stock) - 1);
    var ellx_h1 = hud_s * (1-dsin(rot_h1)) / 2;
    var elly_h1 = hud_s * (1-dcos(rot_h1)) / 2;
    var rot_h2 = 180 * ((player_two.charge/20/player_two.stock) - 1);
    var ellx_h2 = hud_s * (1-dsin(rot_h2)) / 2;
    var elly_h2 = hud_s * (1-dcos(rot_h2)) / 2;
    ////
    var rot_w = 90 * (1 - (player_one.will/2000));
    var ellx_w = hud_s * (1-dsin(rot_w)) / 2;
    var elly_w = hud_s * (1-dcos(rot_w)) / 2;
    var rot_s1 = 90 * (1 - (player_one.shield/2000));
    var ellx_s1 = hud_s * (1-dsin(rot_s1)) / 2;
    var elly_s1 = hud_s * (1-dcos(rot_s1)) / 2;
    var rot_s2 = 90 * ((player_two.shield/2000) - 1);
    var ellx_s2 = hud_s * (1-dsin(rot_s2)) / 2;
    var elly_s2 = hud_s * (1-dcos(rot_s2)) / 2;
    ////
    var plah = 0.9;
    var plav = 0.1;
    draw_set_circle_precision(48);
    surf1 = surface_create(hud_s,hud_s);
    surf2 = surface_create(hud_s,hud_s);
    surf3 = surface_create(hud_s,hud_s);
    surface_set_target(surf1);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    
    //Player 1 goo
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      merge_color(c_lime,0,(player_one.goo-1)/10),
                      merge_color(c_lime,0,(player_one.goo-1)/10),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_b1,elly_b1,-1,1,rot_b1,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      merge_color(c_lime,0,player_one.goo/10),
                      merge_color(c_lime,0,player_one.goo/10),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_g1,elly_g1,-1,1,rot_g1,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      make_color_hsv(16+32*player_one.goo,192,96),
                      make_color_hsv(64+32*player_one.goo,192,96),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_c1,elly_c1,1,1,rot_c1,-1,-1,-1,-1,1);
    ////
    draw_set_blend_mode(bm_subtract);
    //draw_ellipse(0,hud_s*0.35,hud_s,hud_s*0.75,false);
    draw_circle(hud_s/2,hud_s*0.75,hud_s/2,false);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    draw_surface_part_ext(surf1,0,0,hud_s/2,hud_s/2,
                          (1-plah)*hud_w/2,
                          (plav-0.01)*hud_h,
                          (plah+0.1)*0.35*2*hud_w/hud_s,
                          0.14*2*hud_h/hud_s,
                          -1,1);
    surface_set_target(surf1);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    
    //Player 2 goo
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      merge_color(c_lime,0,(player_two.goo-1)/10),
                      merge_color(c_lime,0,(player_two.goo-1)/10),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_b2,elly_b2,1,1,rot_b2,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      merge_color(c_lime,0,player_two.goo/10),
                      merge_color(c_lime,0,player_two.goo/10),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_g2,elly_g2,1,1,rot_g2,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      make_color_hsv(16+32*player_two.goo,192,96),
                      make_color_hsv(64+32*player_two.goo,192,96),false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s/2,
                         ellx_c2,elly_c2,-1,1,rot_c2,-1,-1,-1,-1,1);
    ////
    draw_set_blend_mode(bm_subtract);
    //draw_ellipse_color(0,hud_s*0.35,hud_s,hud_s*0.75,-1,-1,false);
    draw_circle(hud_s/2,hud_s*0.75,hud_s/2,false);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    draw_surface_part_ext(surf1,hud_s/2,0,hud_s/2,hud_s/2,
                          (plah-1)*hud_w/2 - (plah+0.1)*0.35*hud_w + hud_w,
                          (plav-0.01)*hud_h,
                          (plah+0.1)*0.35*2*hud_w/hud_s,
                          0.14*2*hud_h/hud_s,
                          -1,1);
    surface_set_target(surf1);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf3);
    draw_clear_alpha(c_black,0);
    
    //Player 1 stock and charge
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      c_red,c_red,false);
    surface_reset_target();
    draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                         ellx_h1,elly_h1,1,1,rot_h1,-1,-1,-1,-1,1);
    surface_set_target(surf3);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      color_one,color_one,false);
    surface_reset_target();
    draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                         hud_s/2,0,1,1,0,-1,-1,-1,-1,0.45);
    for (var i=0;i&lt;player_one.stock;i++)
        draw_circle_color(hud_s/2 + hud_s*(0.5+0.4)/2*dsin((10+20*i) * 180/20/player_one.stock),
                          hud_s/2 + hud_s*(0.5+0.4)/2*dcos((10+20*i) * 180/20/player_one.stock),
                          hud_s*(0.5-0.4)/2,
                          color_one,color_one,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_r,elly_r,scl_r,scl_r,rot_r,-1,-1,-1,-1,1);
    ////
    draw_set_blend_mode(bm_subtract);
    draw_circle(hud_s/2,hud_s/2,hud_s*scl_r*0.4,false);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    draw_set_halign(fa_right);
    line = "    " + string(player_one.life);
    for (i=5;i&gt;0;i--)
    {   var rot_l = rot_r + (5.5-i)*180/5;
        //var ellx_l = hud_s*(1-dsin(rot_l) + dsin(rot_l)*(1-1*scl_r*1.3))/2 + ((1-plah*0.9)*hud_w-hud_s)/2;
        var ellx_l = (hud_s*(1-dsin(rot_l)*scl_r*1.3) + (1-plah*0.9)*hud_w-hud_s) / 2;
        var elly_l = hud_s*(1-dcos(rot_l)*scl_r*1.3)/2 + (-0.15+plav)*hud_h;
        draw_text_transformed_color(ellx_l,elly_l,
                                    string_char_at(line,string_length(string(player_one.life))+i-1),
                                    hud_w/view_wview[0],
                                    hud_h/view_hview[0],
                                    rot_l,0,0,0,0,1);
    }
    draw_set_halign(fa_left);
    draw_surface_ext(surf1,
                     ((1-plah*0.9)*hud_w-hud_s)/2,
                     (-0.15+plav)*hud_h,
                     1,1,0,-1,1);
    surface_set_target(surf1);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf3);
    draw_clear_alpha(c_black,0);
    
    //Player 2 stock and charge
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      c_red,c_red,false);
    surface_reset_target();
    draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                         ellx_h2,elly_h2,1,1,rot_h2,-1,-1,-1,-1,1);
    surface_set_target(surf3);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      color_two,color_two,false);
    surface_reset_target();
    draw_surface_general(surf3,hud_s/2,0,hud_s/2,hud_s,
                         hud_s/2,0,1,1,0,-1,-1,-1,-1,0.45);
    for (i=0;i&lt;player_two.stock;i++)
        draw_circle_color(hud_s/2 + hud_s*(0.5+0.4)/2*dsin((10+20*i) * 180/20/player_two.stock),
                          hud_s/2 + hud_s*(0.5+0.4)/2*dcos((10+20*i) * 180/20/player_two.stock),
                          hud_s*(0.5-0.4)/2,
                          color_two,color_two,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_r,elly_r,scl_r,scl_r,rot_r,-1,-1,-1,-1,1);
    ////
    draw_set_blend_mode(bm_subtract);
    draw_circle(hud_s/2,hud_s/2,hud_s*scl_r*0.4,false);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    draw_set_halign(fa_right);
    line = string(player_two.life) + "    ";
    for (i=1;i&lt;=5;i++)
    {   rot_l = -(rot_r + (i-0.5)*180/5);
        ellx_l = (hud_s*(1-dsin(rot_l)*scl_r*1.3) + (1+plah*0.9)*hud_w-hud_s) / 2;
        elly_l = hud_s*(1-dcos(rot_l)*scl_r*1.3)/2 + (-0.15+plav)*hud_h;
        draw_text_transformed_color(ellx_l,elly_l,
                                    string_char_at(line,i),
                                    hud_w/view_wview[0],
                                    hud_h/view_hview[0],
                                    rot_l,0,0,0,0,1);
    }
    draw_set_halign(fa_left);
    draw_surface_ext(surf1,
                     ((1+plah*0.9)*hud_w+hud_s)/2,
                     (-0.15+plav)*hud_h,
                     -1,1,0,-1,1);
    surface_set_target(surf1);
    draw_clear_alpha(c_black,0);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    
    //Player 1 will and shield
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      color_one,color_one,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_w,elly_w,-1,1,rot_w,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s*0.41,
                      c_maroon,c_maroon,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_w,elly_w,-1,1,rot_w,-1,-1,-1,-1,0.85);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      c_maroon,c_maroon,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_s1,elly_s1,-1,1,rot_s1,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    
    //Player 2 will and shield
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      color_two,color_two,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_w,elly_w,1,1,rot_w,-1,-1,-1,-1,1);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s*0.41,
                      c_navy,c_navy,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_w,elly_w,1,1,rot_w,-1,-1,-1,-1,0.85);
    surface_set_target(surf2);
    draw_clear_alpha(c_black,0);
    ////
    draw_circle_color(hud_s/2,hud_s/2,hud_s/2,
                      c_navy,c_navy,false);
    surface_reset_target();
    draw_surface_general(surf2,hud_s/2,0,hud_s/2,hud_s,
                         ellx_s2,elly_s2,1,1,rot_s2,-1,-1,-1,-1,1);
    
    //End and clean top display
    draw_set_blend_mode(bm_subtract);
    draw_rectangle(-hud_s*0.1,hud_s*0.5,hud_s*1.1,hud_s,false);
    draw_ellipse(-hud_s*0.1,hud_s*0.17,hud_s*1.1,hud_s*1.67,false);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    draw_surface_stretched(surf1,
                           (1-plah)*hud_w/2,
                           (plav-0.05)*hud_h,
                           plah*hud_w,
                           hud_h*0.3);
    surface_free(surf3);
    surface_free(surf2);
    surface_free(surf1);
    
    //Setup debug display
    if player_one.combo
    {   player_one.raw = raw;
        player_one.output = output;
        player_one.dotal = dotal;
        player_one.dombo = dombo;
        player_two.raw = 0;
        player_two.output = 0;
        player_two.dotal = 0;
        player_two.dombo = 0;
    }
    else if player_two.combo
    {   player_one.raw = 0;
        player_one.output = 0;
        player_one.dotal = 0;
        player_one.dombo = 0;
        player_two.raw = raw;
        player_two.output = output;
        player_two.dotal = dotal;
        player_two.dombo = dombo;
    }
    if !combo and dombo
    {   player_one.combo = 0;
        player_two.combo = 0;
        dombo = 0;
    }
    
    //Show debug
    if debugg
    {   //Player 1 decay stats
        for (i=0;i&lt;16;i++)
        {   switch i%8
            {   case 0: line = 'still: '; break;
                case 1: line = 'tilt:  '; break;
                case 2: line = 'rush:  '; break;
                case 3: line = 'down:  '; break;
                case 4: line = 'up:    '; break;
                case 5: line = 'nair:  '; break;
                case 6: line = 'fair:  '; break;
                case 7: line = 'dair:  '; break;
            }
            if i&lt;8
                line += string(player_one.action[64+i*16,4]);
            else
                line += string(player_one.action[72+(i-8)*16,4]);
            draw_text_transformed_color(0,hud_h*(0.3+0.02*i),
                                        line,
                                        0.3*hud_w/view_wview[0],
                                        0.3*hud_h/view_hview[0],
                                        0,lerp(c_navy,c_maroon,(i-i%8)/8),lerp(c_navy,c_maroon,(i-i%8)/8),
                                        lerp(c_navy,c_maroon,(i-i%8)/8),lerp(c_navy,c_maroon,(i-i%8)/8),1);
        }
        
        //Player 1 debug
        for (i=0;i&lt;10;i++)
        {   switch i
            {   case 0: line = 'Raw: ' + string(player_one.raw); break;
                case 1: line = 'Output: ' + string(player_one.output); break;
                case 2: line = 'Total: ' + string(player_one.dotal); break;
                case 3: line = 'Ground: ' + string(player_one.grounded); break;
                case 4: line = 'Ping: ' + string(puppeteer.ping_avr); break;
                
                case 5: line = 'State: ' + string(player_one.state); break;
                case 6: line = 'Buffer: ' + string(player_one.buffer_mtr); break;
                case 7: line = 'Combo: ' + string(player_one.dombo); break;
                case 8: line = 'Gravity: ' + string(player_one.gvy); break;
                case 9: line = '1000ms: ' + string(puppeteer.ping_m); break;
            }
            draw_text_transformed_color(hud_w*(0.10+0.12*(i-i%5)/5),
                                        hud_h*(0.30+0.03*(i%5)),
                                        line,
                                        0.4*hud_w/view_wview[0],
                                        0.4*hud_h/view_hview[0],
                                        0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
        }
        
        //Player 2 debug
        for (i=0;i&lt;10;i++)
        {   switch i
            {   case 0: line = 'Raw: ' + string(player_two.raw); break;
                case 1: line = 'Output: ' + string(player_two.output); break;
                case 2: line = 'Total: ' + string(player_two.dotal); break;
                case 3: line = 'Ground: ' + string(player_two.grounded); break;
                case 4: line = 'Ping: ' + string(puppeteer.ping_avr); break;
                
                case 5: line = 'State: ' + string(player_two.state); break;
                case 6: line = 'Buffer: ' + string(player_two.buffer_mtr); break;
                case 7: line = 'Combo: ' + string(player_two.dombo); break;
                case 8: line = 'Gravity: ' + string(player_two.gvy); break;
                case 9: line = '1000ms: ' + string(puppeteer.ping_m); break;
            }
            draw_text_transformed_color(hud_w*(0.68+0.12*(i-i%5)/5),
                                        hud_h*(0.30+0.03*(i%5)),
                                        line,
                                        0.4*hud_w/view_wview[0],
                                        0.4*hud_h/view_hview[0],
                                        0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
        }
    }
}

//Frozen display
else
{   if surface_exists(surf0)
        draw_surface(surf0,0,0);
    else
    {   surf0 = surface_create(hud_w,hud_h);
        surface_copy(surf0,0,0,application_surface);
        draw_surface(surf0,0,0);
        instance_deactivate_object(player_one);
        instance_deactivate_object(player_two);
    }
}

//Timer
draw_set_halign(fa_right);
draw_set_valign(fa_bottom);
draw_text_transformed_color(hud_w*0.5,hud_h,
                            string(clock_s)+".",
                            hud_w/view_wview[0],
                            hud_h/view_hview[0],
                            0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
draw_set_halign(fa_left);
draw_text_transformed_color(hud_w*0.5,hud_h*0.99,
                            string(alarm[0]),
                            0.5*hud_w/view_wview[0],
                            0.5*hud_h/view_hview[0],
                            0,c_fuchsia,c_fuchsia,c_fuchsia,c_fuchsia,1);
draw_set_valign(fa_top);

d3d_set_culling(true);
//d3d_set_lighting(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CAMERA

draw_set_color(c_green);
//draw_set_alpha(1);
//draw_set_color(c_white);

//PS3 camera controls
if gamepad_is_connected(0)
{   if (abs(point_distance(0,0,gamepad_axis_value(0, gp_axisrh),
            gamepad_axis_value(0, gp_axisrv))) &gt; 0.2)
    {   mouse_direction += gamepad_axis_value(0, gp_axisrh) * 3;
        zview += gamepad_axis_value(0, gp_axisrv) * 3;
    }
    dist += gamepad_button_value(0, gp_shoulderlb) * 2.5;
    dist += -gamepad_button_value(0, gp_shoulderrb) * 2.5;
}
var cc = cos(zview*pi/180);
var cx = cos(mouse_direction*pi/180)*cc;
var cy = sin(zview*pi/180);
var cz = sin(mouse_direction*pi/180)*cc;
var hc = 050;
var ht = 150;

if g_ready
{   target_x = (player_one.x + player_two.x) / 2;
    target_y = (player_one.y + player_two.y) / 2;
    target_z = (player_one.z + player_two.z) / 2;
}
d3d_set_projection(target_x+(cx*dist),target_y+(cy*dist)-hc,target_z+(cz*dist),
                   target_x,target_y-ht,target_z,xup,yup,zup);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
